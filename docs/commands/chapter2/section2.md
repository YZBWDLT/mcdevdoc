---
sidebar_position: 2
---

# 2.2 简单命令

本节，我们将带你来了解 9 条你可能早已听说的命令。这些命令出名到什么地步？甚至连一些不搞开发的 UP 主、普通玩家、生存玩家，都对这些命令有所耳闻。你也很可能听过这些命令的鼎鼎大名。那我们一起来看一看吧！

---

## 帮助命令：`/help`

这条命令，我们曾在第一章时讲过，**它会返回特定页码或命令的帮助信息**。它有两条语法：

```text title="/help的语法" showLineNumbers
/help <页码: int>
/help [命令: CommandName]
```

例如，我们在 1.1 曾经布置了一道练习，要求你利用`/help`自学`/difficulty`。是否有印象呢？这里我们就是利用了第二条命令。

![/help difficulty](/commands/chapter2/section2/help_difficulty.png)

这条命令还需要再介绍吗？我们认为应该无需多言了。

讲两句题外话。其实，我们认为这条命令的必选和可选参数的信息，可能有标注错误的嫌疑。实际的语法应该是

```text title="/help的实际语法" showLineNumbers
/help [页码: int]
/help <命令: CommandName>
```

这样，当你只输入`/help`的时候，页码默认为 1，所以返回第 1 页的信息；而查询命令则必须要你写入一条命令的名字。想想是不是这个道理？

---

## 给予玩家物品的命令：`/give`

嘿嘿，这位也是老朋友啦。我们曾经在讲物品这个概念的时候，学习过`/give`的语法。

还记得是什么语法吗？其实不记得也不要紧。真的！因为你随时都可以查文档，在实际运用的时候，旁边不会有监考老师监督你去做命令或者做什么，所以更重要的是你要知道这条命令能做什么，然后多加运用，你想记不下来都难！

那我们现在把这条命令的语法贴出：

```text title="/give的基本语法" showLineNumbers
/give <玩家: target> <物品: Item>
```

例如，`/give @a apple`，这里`玩家`是所有玩家（`@a`），`物品`是苹果（`apple`），所以是给予所有玩家苹果。有印象了吧！那我们接下来就要进行扩展了。

### `/give`的扩展语法

还记得吗？我们曾经介绍基本语法的时候说，这条命令将给予`玩家` 1 个`物品`。为什么是 1 个？来，我们看看这个基本用法的命令参数。发现有什么特点了吗？没错，都是必选参数！这条命令后面还跟了三个可选参数，其中一个就是指代物品数量的。我们来看看这条扩展语法：

```text title="/give的扩展语法" showLineNumbers
/give <玩家: target> <物品: Item> [数量: int] [数据值: int] [组件: json]
```

![/give](/commands/chapter2/section2/give.png)

感觉除了`数量`都看不懂？没事，我们先来看`数量`，剩下两个我们一会儿解释。你可以看到，它接受一个`int`类型的参数，也就是整数。这很好理解，毕竟你不能给予 1.5 个苹果，对吧？`数量`是一个可选参数，这就是我们不指定也能成功运行的原因。**对于每一个可选参数，都存在一个默认值**。在这里，默认值就是`1`。也就是说，如果你不填写，它就只给予 1 个苹果。很简单吧？我们来实战一下。

:::tip[实验 2.2-1]

尝试写一条命令，给予你一组钻石。执行之以验证你的想法！

<details>

<summary> 点我查看答案！ </summary>

`/give @s diamond 64`

</details>

:::

因此，现在你就知道：`/give`是能够给予`数量`个物品的。

### 物品数据值

物品数据值的概念稍微复杂一点。一个物品，也是可能具有多个状态的。例如，当你使用一把钻石剑杀死了一只僵尸，这把剑的耐久度会降低，也就是说不同的耐久度定义了同一个物品的不同状态。像这样，**同一个物品的不同状态就用数据值（Data Value）来记录**。特殊地，我们这里说的数据值指代的是物品数据值。

我们看到，`数据值`的类型是`int`，并且为可选参数。相信看到这里，不用我们说，你也知道这个参数该填什么了。该参数的默认值是`0`。

一切物品都可以拥有数据值，不同数据值的同类物品，在物品栏也不能合并。特殊地，对于工具，数据值就代表着它的损坏值。例如，在 [Wiki](https://zh.minecraft.wiki/w/剑) 中可以查到钻石剑的耐久是 1561 点，那么使用`/give @s diamond_sword 1 1000`就会给予你一把损坏了 1000 点耐久值，也就是剩余 561 点耐久的剑。

:::info[思考 2.2-1]

为什么这里必须代表损坏值而非耐久值呢？

:::

![/give @s diamond_sword 1 1000](/commands/chapter2/section2/give_diamond_sword.png)

至于`组件`，我们认为现在聊这些还太早，我们希望等到你有更多的基础之后再来聊这些，不过你很快就会再次见到它的身影！

至此，我们可以给`/give`命令的含义做一个完全的总结：**`/give`将给予`玩家` `数量`个含有特定`组件`、特定`数据值`的`物品`**。

:::note[扩展：关于物品数据值的历史问题]

我们现在已经知道，数据值用来储存同一个物品的不同状态。刚刚我们列举了一个耐久度（或者准确来说叫做损坏值）的例子，和不同数据值的物品来和正常的物品作区分的例子。目前的数据值大体上也就只有这点应用了。

但是在以前，数据值的应用极为广泛，这里就不得不说到**扁平化（Flattening）** 所带来的影响了。如你所知，现在红色羊毛的 id 为`red_wool`、蓝色羊毛的 id 为`blue_wool`、等等等等，但是在以前，这些所有颜色的羊毛统称为`wool`，那么如何指定羊毛颜色呢？比如红色，我们就指定`wool`的数据值为`14`，黄绿色是`5`、黄色是`4`，以此类推。好记吗？当然不好记！所以常用的做法是，要么试，要么查。很明显，**扁平化就是把这种*压缩的 id* 给扩展开来，展开为多个不需要数据值也能良好定义的物品 id**。

这样做的好处当然是很明显的，**代码变得更易读**：相比于`/give @a wool 1 14`，显然`/give @a red_wool`更能让人一眼看懂这条命令的含义。当然缺点也是有的，因为 id 的变化，导致老 id 在`hasitem`目标选择器参数的高版本适配中表现不佳；而且对于手机版玩家来说，要打的字又变多了，会更麻烦。

扁平化这个概念，最早出现在隔壁的 Java 版。在 Java 版 1.13，Mojang 将所有物品、方块（是的，以前方块也有数据值）的数据值通通消灭，全部进行了扁平化，特殊状态则转而使用 NBT 来代替。这也是当时的模组难以转换到高版本的一个重要原因，因为原版 ID 几乎是被重写了一轮，所以 Forge 没有办法及时作出适配。这也是很多模组玩家至今卡在 Java 版 1.12.2 的原因，因为很多模组从那之后就停更了，或者不愿再对高版本做出适配。

基岩版的扁平化则是从 1.19.70 的一次物品、方块 ID 拆分悄然开始的，直到现在，已经渐渐接近尾声。与 Java 版大刀阔斧地改，全然不顾向下兼容性不同，基岩版并没有任意选择版本的功能，因此 Mojang 为了对旧版地图、附加包有一定的适配，不至于让它们报废，这些老 id 还是可用的，不过自动补全就不会帮上你了。**我们现在使用新版本时，还是尽可能地使用新版 id，适配性更好的同时也更加易读**。

:::

---

## 清除物品的命令：`/clear`

说到物品操作，有给予就必定要有清除。我们现在就来介绍这条**清除物品的命令**：`/clear`。它的语法是：

```text title="/clear的语法" showLineNumbers
/clear <玩家: target> <物品: Item> [数据值: int] [最大数量: int]
```

![/clear](/commands/chapter2/section2/clear.png)

**这条命令将清除`玩家`至多`最大数量`个数据值为`数据值`的`物品`**。

可以看到，这条命令和`/give`有很多相似处。

:::tip[实验 2.2-2]

我们现在要给予自己一个苹果，再移除自己的苹果。这可以写为

```text showLineNumbers
/give @s apple
/clear @s apple
```

试执行之，体验一下这两条命令。在物品栏里再拿出一组苹果，然后再执行一次，体验一下`最大数量`的含义。

:::

关于`数据值`，这是一个`int`类型的可选参数。其基本含义和`/give`是一致的，例如可能代表物品的状态、损坏值等等。但是，这里和`/give`有一点是不同的。我们可以试想一个情况：如果要清除玩家的钻石剑，但是玩家有多把钻石剑，损坏值或为 500，或为 1000，或为 1500 等数值，这种要穷举每种损坏值的情况自然是不现实的。因此，**我们可以使用一个负数值来代表任意数据值的情况**。例如：`/clear @a diamond_sword -1`就将移除所有玩家在任意损坏值的钻石剑。显然，`数据值`的默认值应当是一个负数，事实上其默认值为`-1`。

:::info[思考 2.2-2]

`/give`能否给予一个负数值数据值的物品，例如`/give @a apple 1 -1`？试分析之并在游戏中验证你的想法。

:::

而`最大数量`则被设立为第 4 个参数，这和`/give`是不同的（`/give`的`数量`参数是第 3 个参数），因此这也是该命令使用的一个常错点。此外，注意该参数的描述为`最大数量`。和目标选择器参数`c`类似，即使物品数量少于这个值，也能够执行。我们以`/clear @a apple -1 3`为例：

- 如果你有 20 个苹果，那么最多清除 3 个，所以最终你有 17 个苹果；
- 如果你有 2 个苹果，那么最多清除 3 个，所以全部清除，你有 0 个苹果。

特别地，`最大数量`可以被填写为`0`。你可能会问：清除`0`个物品有什么意义？事实上，如果你拥有这个物品，这条命令不会清除你的物品，但是成功执行；而如果你没有这个物品，这条命令就将执行失败。换言之，`最大数量`为`0`时，这条命令将起到检测物品作用。这在 1.18.30 之前，没有`hasitem`的时候是很常用的检测物品的手段。

![/clear @s apple -1 0](/commands/chapter2/section2/clear_apple_0.png)

---

## 更改玩家游戏模式的命令：`/gamemode`

这条命令你很可能已耳熟能详！很多人初接触命令时，可能就是先接触的这条命令。废话少说，我们直接上语法：

```text title="/gamemode的语法" showLineNumbers
/gamemode <游戏模式: int|GameMode> [玩家: target]
```

![/gamemode](/commands/chapter2/section2/gamemode.png)

**这条命令将把`玩家`调整为`游戏模式`**。特别简单易懂的命令！

在游戏中，给出了两条语法。实际上，你可以看到它们之间只有接受类型的不同，因此我们在上面将两种类型`int|GameMode`合并到一个参数，代表该参数既接受`int`类型，也能接受`GameMode`类型，希望你能理解。

这个命令参数的类型是我们未曾遇到过的，然而自动补全已经告诉你可以填写什么。很显然，这个参数接受简写或全称的游戏模式的写法。因为首字母大写，这是一个穷举参数，意义是很明确的。我们在下文给出一个表，作为对应。

| 游戏模式 | `GameMode`的全称写法 | `GameMode`的简称写法 | 对应的`int` |
| :---: | :---: | :---: | :---: |
| 生存模式 | `survival` | `s` | `0` |
| 创造模式 | `creative` | `c` | `1` |
| 冒险模式 | `adventure` | `a` | `2` |
| 默认模式 | `default` | `d` | `5` |
| 旁观模式 | `spectator` | — | — |

:::tip[实验 2.2-3]

例如，调整 Alex 为生存模式，就可以用`/gamemode survival Alex`。当然，`/gamemode s Alex`和`/gamemode 0 Alex`都是可以的。试执行下面的命令，体验一下这条命令。如果害怕被史莱姆攻击影响输入命令，可以开和平。

```text
/gamemode survival @s
```

:::

其中，旁观模式不存在简称写法和对应的`int`。本教程一贯建议：为顺应 Java 版的趋势，**游戏模式应写为全称写法**。

:::note[扩展：为什么旁观模式不存在简称和数字写法？]

这是因为，Java 版自 1.13 后，该命令仅支持全称写法，而旁观模式在基岩版加入时间较晚，所以为了顺应 Java 版的趋势，就不再允许该模式写为简称或数字。旁观模式在 Java 版 1.12 以前的简称写法为`sp`。基岩版在刚加入旁观模式时，允许使用数字`6`指代该模式。

:::

### 默认游戏模式

默认模式的概念其实特别简单。每个世界都存在一个默认游戏模式，每个玩家都可能是特定的游戏模式，也可能是默认游戏模式。只要你是默认游戏模式，就跟随这个世界的默认游戏模式来确定你的游戏模式。然而，这个概念确实是很少提及，也不太常用的。

![默认游戏模式](/commands/chapter2/section2/default_gamemode.png)

### 冒险模式

冒险模式是一种类似于生存模式的游戏模式。然而，与生存模式不同的是：**你不能随意地破坏方块、或者放置方块**。只有使用命令给予的含有特定`组件`的物品，或者在允许方块之上，才能够进行放置、破坏等操作。

其中，`组件`这个东西已经被我们按下不表，我们打算在后续章节再和你谈这些。不过你可以先看到这些物品大体的特征如下：

![冒险模式可用的物品](/commands/chapter2/section2/usable_block_in_adventure.png)

而允许方块，则是我们在第 3 章要着重介绍的东西。

### 旁观模式

旁观模式是一种允许玩家进行世界旁观的模式。在该模式下，玩家将能够飞行、允许穿墙、不能对世界进行任何操作等诸多重要特性。如果你正在做一张多人地图、或者希望玩家能够参观此地图、或者就是单纯地想找找地下的一些结构，等等需求，那么你很可能会用到这个模式！

![旁观模式](/commands/chapter2/section2/spectator_mode.png)

:::note[扩展：Java 版的旁观模式]

Java 版的旁观模式还能够通过鼠标滚轮改变飞行速度，以及能够进入生物（包括玩家）的视角。很遗憾，基岩版并没有这些。

:::

### 目标选择器参数`m`

`m`取自于**M**ode，即**查找特定游戏模式的玩家**。其语法为：

```text title="目标选择器参数m的语法" showLineNumbers
m=<游戏模式: int|GameMode>
```

例如：`@a[m=creative]`将找到所有创造模式的玩家，`@a[m=c]`或`@a[m=1]`也是同样的效果。

:::tip[实验 2.2-4]

依次执行下面的命令。

```text showLineNumbers
/testfor @s[m=creative]
/gamemode creative @s
/testfor @s[m=creative]
```

:::

该参数支持反选，例如你可以使用`@a[m=!adventure]`来找到所有不是冒险模式的玩家。

`m`只能指定一次。

:::info[思考 2.2-3]

如果`m`能够指定多次，`@a[m=creative,m=survival,m=spectator]`能否实现`@a[m=!adventure]`相同的效果？

:::

---

## 清除实体的命令：`/kill`

我们曾经学习过`/summon`是生成实体的命令。`/kill`则是与`/summon`相反的命令，**用于清除特定的实体**。语法为

```text title="/kill的语法" showLineNumbers
/kill [目标: target]
```

![/kill](/commands/chapter2/section2/kill.png)

**这条命令将杀死`目标`**。

`目标`的默认值为`@s`。这个语法已经简单到无需我们再多说什么了。直接上实例：

- `/kill`：杀死执行者自身。当然，如果你是创造模式，那么你是无法被杀死的。
- `/kill @e`：杀死所有实体。**当心！这在很多地图、模组中都是很危险的行为！**
- `/kill @e[type=sheep]`：杀死所有绵羊。
- `/kill @e[type=item]`：清除所有掉落物。别忘了掉落物也是实体哦！

---

## 调整时间的命令：`/time`

`/time`是用于调整时间的命令。这条命令之所以“人尽皆知”，主要是因为基岩版有一个快速的自动命令输入功能：

![/time命令的UI](/commands/chapter2/section2/time_ui.png)

这个界面可以让一名完全不懂命令的玩家也能轻易地更改时间。但是，我们现在并不能说自己完全不懂命令，我们的目标不应当局限于此。我们来看一下这条命令的语法：

```text title="/time的语法" showLineNumbers
/time add <数值: int>
/time query <day|daytime|gametime>
/time set <数值: int>
/time set <时间: TimeSpec>
```

![/time](/commands/chapter2/section2/time.png)

上面我们给出的语法中，和游戏内并不完全一致，这是因为`TimeQuery`类型是一个穷举参数，仅支持 3 种穷举条目：`day`、`daytime`和`gametime`，所以我们直接展开写。

这条命令一共有 4 条语法，但事实上只有 3 个用法：`add`、`set`和`query`。我们挨个来解释。

### 设置时间

设置时间是我们最常用的用法，也就是`set`的那两条语法。我们看到`/time set <数值: int|时间: TimeSpec>`（这里也采用合并式写法）应当是接受一个数值或一个`TimeSpec`类型的参数的。

`数值`上，我们需要简单讲一讲。首先，有两个原理需要你了解：

1. Minecraft 中的一天，对应现实是 20 分钟，也就是 1200 秒。
2. Minecraft 存在一种叫做“游戏刻”的概念。游戏刻（Game Tick，简称 gt）简单来说，是指 Minecraft 完成一次代码循环所需的时间。对于 Minecraft，**1 秒 = 20 游戏刻**。这是**极其重要的时间换算原理**，因为在后面的`/scoreboard`、命令方块、函数、脚本等各方面，这个原理都无处不在，我们会在后面遇到的时候反复提及。执行一条命令所需要消耗的时间就是 1 游戏刻。关于游戏刻的更多说明，你可以参见 [Wiki 的这个页面](https://zh.minecraft.wiki/w/刻)。

因此，换算为游戏刻，Minecraft 的一天就是 1200×20=24000 游戏刻。`数值`所接受的就是以游戏刻为单位的整数。Minecraft 的白昼和黑夜几乎是一样长的，因此，`0`代表着一天初始；`12000`代表着黄昏，一天的夜晚即将到来；`6000`就是正午；而`18000`就是午夜时分。每`1000`游戏刻，在 Minecraft 中就代表着过去了 1 个小时。关于昼夜更替，你也可以参见 [Wiki 的这个页面](https://zh.minecraft.wiki/w/昼夜更替)。

而`TimeSpec`，事实上它也是一种穷举参数，能够接受 6 种特殊时间。对应表格如下：

| 时间 | `数值: int` | `时间: TimeSpec` | 备注 |
| :---: | :---: | :---: | --- |
| 日出 | `23000` | `sunrise` | 早上 5:00，注意不是早上 6:00 |
| 早上 | `1000` | `day` | 早上 7:00 |
| 正午 | `6000` | `noon` | 中午 12:00 |
| 日落 | `12000` | `sunset` | 晚上 6:00 |
| 晚上 | `13000` | `night` | 晚上 7:00 |
| 午夜 | `18000` | `midnight` | 0:00 |

我们来举几个例子：

- `/time set 0`：设置为早上 6:00。
- `/time set noon`或`/time set 6000`：二者完全等价，设置为正午。
- `/time set 36000`：设置为第 2 天的日落时分。注意 36000 是第二天的时间范围。

### 增加时间

如果你理解了设置时间的那些内容的话，那么增加时间对你来说已经不再是一个难题。原理上来说，数值计算都是一样的。我们直接以例子讲解：

- `/time add 1`：时间加快 1 游戏刻。
- `/time add -1`：时间倒退 1 游戏刻。
- `/time add 24000`：迅速经过一天。如果为夜晚，你可以用这条命令观察到月亮的变化哦！

### 查询时间

查询时间，也就是`/time query <day|daytime|gametime>`，允许你查询这个世界目前所处于第几天（`day`）、什么时间（`daytime`）、以及这个世界总共运行了多久（`gametime`）。如果你想跟你的小伙伴“吹嘘”自己的世界玩了多久的话，不妨来试试这条命令吧！

:::tip[实验 2.2-5]

依次执行下面的命令。

```text showLineNumbers
/time query day
/time query daytime
/time query gametime
```

:::

最终，游戏将返回给你下面这个类似的消息：

![/time query](/commands/chapter2/section2/time_query.png)

天数和当前时间都是好理解的。而对于游戏时间，依据时间换算原理（1 秒 = 20 游戏刻），你可以将这个值除以 20，就是你这个世界所启动了的秒数。

---

## 传送玩家的命令：`/tp`（或`/teleport`）

---

## 发送消息的命令：`/say`

---

## 调整天气的命令：`/weather`

---

## 总结与练习
