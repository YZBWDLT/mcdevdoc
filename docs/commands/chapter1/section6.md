---
sidebar_position: 6
---

# 1.6 目标选择器

本节我们来介绍目标选择器这个基本概念。事实上，在你不知不觉中，就已经在前面见过它了。为什么我们需要目标选择器？还记得我们在 [1.3 实体](section3)曾说过的：

> 这是因为在实际的工程里面，会用到大量有关于实体操作的命令。有很多命令是用于控制实体的。实体拥有比较良好的执行性和灵活度（因为有旋转和位置变量），所以很多情况下我们都需要一些实体来辅助我们实现一些特殊功能。

但是我们又在那一节中说，使用实体 ID 的命令只有`/summon`一条。既然如此，为什么说“有很多命令是用于控制实体”的呢？这就不得不提到目标选择器了。

---

## 命令`/tp`的扩展

让我们试想这样一个需求：我们现在要传送一只绵羊到(0,256,0)的位置上。听起来很不可思议！因为我们曾经学过，`/tp`是用于传送执行者到特定位置的，在目前，我们所学习的聊天栏执行的命令中，我们才是执行者，绵羊是不能成为执行者的。但细心的你一定已经发现：我们所学的只是`/tp`的冰山一角！为什么呢？因为当我们输入`/tp`后：

![完整的tp语法](/commands/chapter1/section6/full_tp.png)

它拥有整整 10 条语法！而且我们曾学过的`/tp <位置>`也只是图中第 2~4 种语法的简写形式而已。

让我们关注这张图的第 1\~5 种语法和第 6\~10 种语法，并进行比对，你发现了什么？

没错！下面的命令都多出来了一个`<victim: target>`参数！也就是说，我们以前所学的命令

```text
/tp <位置: x y z>
```

可以扩展为

```text
/tp <目标: target> <位置: x y z>
```

这样，`/tp`的意义就变为：将`目标`传送到`位置`上，也就是说，你可以指定特定的目标进行传送！这些目标，允许的类型就是实体，你可以指定一个合适的实体，将它传送到特定位置。

你可能也已经注意到，`<目标>`的`类型`是`target`，我们好像在哪里见过？没错！在`/give`命令中我们也曾见过这个参数类型。当时我们说，`target`可以填写为自己的昵称，而现在你已经知道，`target`是用于指代实体的类型，因此玩家的昵称自然也在这个行列之中。

然而，我们如何利用`target`指代一个实体呢？难道是直接写`sheep`？且不说就算它能生效，原则上也是对所有的绵羊生效，不能指定到我们希望传送的那只羊身上，实际这样写也是根本无法生效的。让我们来分析这样一条命令：

```text
/tp sheep 0 256 0
```

让我们考虑这么一种情况：一位名字叫`sheep`的玩家加入了游戏，这时是传送绵羊还是传送玩家？

不难发现，这种情况会造成歧义。因此，游戏认为，输入一个普通的字符串是传送名字为`sheep`的玩家，而不是绵羊。如果没有名字为`sheep`的玩家，游戏将会报错：

![传送sheep玩家](/commands/chapter1/section6/tp_player_sheep.png)

这种报错：`没有与选择器匹配的目标`代表命令的语法是正确的，但是找不到这样的实体。那我们怎么指代绵羊呢？

---

## 目标选择器

为了指定特定的实体，我们需要引入 **目标选择器（Target Selector）** 这个概念，因为是专门指定实体的，因此又称为 **实体选择器（Entity Selector）**。[Wiki](https://zh.minecraft.wiki/w/目标选择器) 给出的概念为

> 目标选择器（Target Selector）又名实体选择器（Entity Selector），可在无需指定确切的玩家名称或UUID的情况下在命令中选择任意玩家与实体。目标选择器变量可以选择一个或多个实体，目标选择器参数可以根据特定条件筛选目标。

类型为`target`的命令参数，不仅接受玩家昵称，也接受目标选择器。例如`/tp @e ~~~`，其中的`@e`就是一个目标选择器。至于这个选择器代表什么，很快你就会认识到。

要使用目标选择器，我们必须了解目标选择器如何编写。一般来说，目标选择器由两部分组成：**目标选择器变量**和**目标选择器参数**，但是目标选择器参数是可选的。

---

## 目标选择器变量

目标选择器变量（本节下文简称为变量），用于大体上地划定并选择实体范围。

变量的写法为`@(字符/字符串)`，例如`@a`、`@e`或`@initiator`。

基岩版一共有 6 种变量，其中 5 种都有很重要的用途。我们来一一认识一下这 5 种目标选择器变量！

### `@a`：选定所有玩家

`@a`中的`a`代表的是 **A**ll Players 的 A，因此，**使用`@a`将选中所有玩家**。我们来回顾一下`/give`命令的语法：

```text
/give <玩家: target> <物品: Item>
```

接下来，我们来使用`@a`做个实验吧！

:::tip[实验 1.5-1]

执行命令`/give @a apple`。你现在应该能够看懂这条命令：它将给予所有玩家一个苹果。

![给予所有玩家苹果](/commands/chapter1/section6/give_@a.png)

:::

特别地：`@a`是直接选取的玩家，**无论玩家目前是死亡状态还是存活状态、是创造模式还是生存模式等，只要是玩家就都会被`@a`选中**。

### `@e`：选定所有实体

`@e`中的`e`代表的是 **E**ntity 中的 E，因此，**使用`@e`将选中所有实体**。我们来使用`@e`做一个实验：

:::tip[实验 1.5-2]

执行命令`/tp @e ~~~`。在执行之前，你可以试着分析一下这条命令的含义，在游戏内执行后，看看符不符合你的预期。

![传送所有玩家](/commands/chapter1/section6/tp_@e.png)

:::

是的，这条命令会把所有的实体全都传送到你的身上！你分析对了吗？

在使用这个目标选择器的时候，请务必注意三点：

1. `@e`会选定所有实体，**这个范围是相当大的**！因此，我们在使用该变量的时候，一般都要搭配目标选择器参数，来限定选中的实体。直接使用`@e`一般都是很危险的，用之前请务必谨慎！
2. `@e`**不会选定已经死亡的实体**。依据这个原理，我们很快就会了解到，`@a`和`@e`的联合应用可以精确地检测到哪个玩家处于死亡状态。
3. **部分命令只能接受玩家类型的实体**。因此，`@e`在某些`target`类型的命令中也会报错。

### 限定玩家类型的`target`命令参数

我们来看这样一个实验：

:::tip[实验 1.5-3]

执行命令`/give @e apple`。

:::

执行上面的命令，将会报错。这是因为有相当多的实体是不存在物品栏这个概念的，所以一些类型为`target`的命令是不允许更广泛的实体概念参与的，而只允许玩家。后面你会看到更多类似的命令，例如`/gamemode`。

![给予所有实体苹果](/commands/chapter1/section6/give_@e.png)

对于这类仅限玩家的命令，你可以注意到命令参数一般为`player: target`，限定玩家，而不是`victim: target`、`entity: target`等更广泛的描述。在`/give`中，对应的参数就是`<player: target>`。

### `@p`：选定最近的玩家

`@p`中的`p`代表的是 Nearest **P**layer 中的 P，因此，**使用`@p`将选中最近的玩家**。

也许你会问一个问题：这里的最近是指距离什么位置最近呢？很显然，就目前来说，我们的执行位置就是我们自己的位置，因此，离我们最近的玩家自然就是我们自己。那么这样的话，如何指定距离特定位置最近的玩家，而不是总指定到我们自己呢？先不要紧，我们马上就会了解到这一点。当然，在你学习 [2.3 的命令执行原理](../chapter2/section3)后，你会更加深刻地了解到这一点。

特别地，`@p`只选择活着的玩家。

### `@r`：选定随机的玩家

`@r`中的`r`代表的是 **R**andom Player 中的 R，因此，**使用`@r`将选中最近的玩家**。不过，`@r`也是可以选定随机实体的，稍后你就能看到这一点。

### `@s`：选定执行者

`@s`中的`s`代表的是 **S**elf 中的 S，因此，**使用`@s`将选中执行者本身**。显然，`/tp <位置>`和`/tp @s <位置>`的效果是完全等同的，因此，扩展的语法完全能够代替我们以前所学的语法，从今以后，我们讨论`/tp`时，就将讨论扩展的语法：

```text
/tp <目标: target> <位置: x y z>
```

---

## 目标选择器参数

我们注意到一点：即使我们能够通过`@e`等方法指代其他实体，但是我们一开始的需求并没有解决。如何指定一只绵羊呢？这就需要目标选择器参数来进行更进一步的筛选。

目标选择器参数（本节下文简称为参数），是在变量选中的实体的基础上，再通过参数中所给的条件进行筛选。参数是跟在变量之后的，并且用中括号包裹：

`@变量[参数1=值1,参数2=值2,...]`

不同参数的筛选原则，采用“和”的逻辑，即：在变量选中的实体的基础上，筛选出符合`参数1=值1`、并且`参数2=值2`、并且`...`的所有条件的实体。

接下来，我们介绍几个比较常用的参数。对于下面所给的例子的目标选择器，例如`@e[r=10]`，你可以通过`/tp <目标选择器> ~~~`命令来自己进行测试。

### 实体的碰撞箱

在介绍接下来的概念之前，我们首先要介绍一下实体的**碰撞箱（Collision Box）**。在 Minecraft 中，碰撞箱经常用于各种判定。每个实体都拥有一个长宽相等的碰撞箱，例如玩家在站立时的碰撞箱的高度就是 1.8 格，宽度为 0.6 格，因此玩家在站立时，就无法穿过 1.5 格高的洞口。

![碰撞箱](/commands/chapter1/section6/collision_box.png)

下文中的`r`、`rm`、`dx`、`dy`、`dz`都是进行区域检测的参数，它们的判定标准是：**只要碰撞箱有和检测区域重叠的部分，就视为检测通过**。

### `r,rm`：指定特定距离内的实体

参数`r`的 r，取自 **R**adius，也就是半径的意思。**`r`将选中在特定半径内的实体**。它所能接受的值为浮点数类型。我们来举几个例子：

- `@e[r=10]`：指代执行者周围 10 格的实体；
- `@a[r=5]`：指代执行者周围 5 格的玩家。

而参数`rm`，相比于`r`多了一个 m，取自 **M**inimum，结合起来看，就是最小半径。换言之，**`rm`将选中在特定半径外的实体**。同样地，它所能接受的值为浮点数类型。我们来举几个例子：

- `@e[rm=10]`：指代执行者 10 格之外的实体；
- `@a[rm=5]`：指代执行者 5 格之外的玩家；
- 特殊地，`@e[rm=0]`：指代执行者 0 格之外的实体，换言之，选中此维度的所有实体。

在这一小节的一开始，我们说过可以使用多个参数，并采用“和”的逻辑。同样地，`r`和`rm`可以并用，并选中特定区域的实体（图片来自 Minecraft Wiki）：

![r与rm并用](/commands/chapter1/section6/r_rm.png)

在这张图中，绿色球壳的部分就是检测区域，而蓝色的立方体指代实体的碰撞箱。只要实体的碰撞箱与绿色部分的检测区域有重叠，就认为检测通过。我们同样举几个例子：

- `@e[rm=5,r=10]`：指代距执行者 5~10 格的实体。
- `@a[rm=1.5,r=5]`：指代距执行者 1.5~5 格的玩家。
- `@a[rm=5,r=4]`：指代距执行者 5~4 格的玩家。很显然，不可能存在这样的实体，因此这条命令将会报错。所以，这里必须满足`r`>`rm`。

![r>rm将会报错](/commands/chapter1/section6/rm_greater_than_r.png)

### `dx,dy,dz`：指定一个立方体区域内的实体

参数`dx`、`dy`、`dz`的 d，均指代 **D**elta，也就是变化量、差值的意思。换言之，**`dx`将找到与执行者在 x 坐标上相差 dx 的实体**，而`dy`、`dz`以此类推。三个值的默认值为`0`。

我们不得不说，这样的基本描述确实很抽象，因此我们将结合例子来进一步帮助你加深对这个参数的理解。

:::tip[实验 1.5-4]

依次执行命令：

- `/tp @s 0 -60 0`
- `/tp @e[dx=30,dz=40] ~~~`。

:::

你会发现，第一象限的大多数实体都被传送到你的位置上。我们来解析一下这个结果。

首先我们先假设(0,-60,0)（红）和(5,-55,5)（蓝）有两个方块，那么它们所成的长方体区域就将如下图所示：

![两点确定一个长方体区域](/commands/chapter1/section6/volume_by_two_pos.png)

这表明**两个坐标能够确定一个长方体区域**。接下来，我们回到上面的实验结果分析。第一条命令执行后，你的位置现在为(0,-60,0)，那么执行第二条命令后，游戏将会寻找坐标1(0,-60,0)和坐标2(0+30,-60+0,0+40)（注意：`dy`的默认值为`0`）所确定的长方体区域的实体，也就是下面所框选的范围（其中红色的长度为30格，表示dx，蓝色为40格，表示dz）：

![dx与dz确定的范围](/commands/chapter1/section6/dx_30_dy_40.png)

事实上，在一般情况下，如果执行者的位置为(x,y,z)，那么`@e[dx=(dx),dy=(dy),dz=(dz)]`将会寻找坐标1(`x`,`y`,`z`)和坐标2(`x+dx`,`y+dy`,`z+dz`)所确定的长方体区域的实体。例如：

- 当你的位置在(30,40,50)时，使用`@e[dx=30,dy=40,dz=50]`将选中(30,30,30)和(60,80,100)所成区域内的实体。
- 当你的位置在(-5,-5,-5)时，使用`@e[dx=-20]`将选中(-5,-5,-5)和(-25,-5,-5)所成区域内的实体。
  - 什么？这是一条直线？是的！但是我们前文曾说过，只要碰撞箱有和检测区域重叠的部分，就视为检测通过。所以，只要实体的碰撞箱和这条线相交，就能够检测通过。
- 当你的位置在(0,320,0)时，使用`@e[dy=50]`将选中(0,320,0)和(0,370,0)所成区域的实体。

### `x,y,z`：指定参数的参考位置

### `type`：指定特定类型的实体

### `name`：指定特定名称的实体

### `c`：指定至多选中多少个实体

### `hasitem`：指定拥有特定物品的实体

---

## 总结与练习
